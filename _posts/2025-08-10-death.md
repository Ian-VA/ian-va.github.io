---
layout: post
title: The Unpragmatic Programmer
date: 2025-08-10 19:39:00
tags: programming ai
description: vibe coding, and Plato's allegory of the cave
featured: true
---

Companies have been flying AI as their latest proud banners to signal efficiency. From ["agentic AI"](https://www.mckinsey.com/capabilities/quantumblack/our-insights/seizing-the-agentic-ai-advantage) pushed by consultants to the undying "we'll have AGI in 2 years, guys, trust me", the closest metaphor I can think of to the AI hype is a pandemic, the vectors of which are LinkedIn and Sam Altman's twitter posts.

Many experienced software engineers are quick to point out the issues with shoving LLMs down everyone's throats, while budding programmers are all too eager to feed their latest homework assignment into chatGPT. Who's on the right side of history here?

To be clear, I don't dislike Artificial Intelligence. I sometimes use it for UIs I really don't feel like doing, or boilerplate code that I'm confident has been rewritten a thousand times before (and would thus appear a thousand times in the latest illegally web-scraped LLM dataset). I'd even go as far to say I'm a fan of AI-assisted coding. Indeed, it would be a fool's errand to say that AI-assisted coding is bad, just like it would have been a fool's errand to say higher-level programming languages are bad when everyone was still toiling in Assembly. 

[Vibe coding](https://en.wikipedia.org/wiki/Vibe_coding), however, is corrosive and dangerous. It leads to security vulnerabilities, dead code, performance issues, and unreadable slop. [Take a look at Tea](https://www.businessinsider.com/tea-app-data-breach-cybersecurity-ai-vibe-coding-safety-experts-2025-8): the vibe-coded app that left its user's private information (pictures and driver's licenses) accessible through a web browser.

Vibe coding has given birth to a subset of software developers I call the "Unpragmatic Programmers". The Unpragmatic Programmer knows nothing of the tools he uses, like a carpenter clueless about rulers; he veils cataclysmic technical debt with a clunky UI and flashy presentations; indeed, all he knows about computer science is the ramblings of a mathematical model injected with far too much money, like a 21st century Plato's Cave. Never before has cutting corners, in education and in practice, been so unanimously celebrated. 

Of course, maybe I'm an old geezer already and can't get with the times. Let's put the Unpragmatic Programmer lifestyle to the test.

---
## Testing the Manhattan Project

Sam Altman likened GPT-5 to the Manhattan Project in terms of its power and capacity for change. Let's take him up on that and vibe-code a video streaming app.

I first asked GPT-5 to give me a simple video streaming app in Python with file uploading functionality. The Manhattan Project returned this:

```python
from flask import Flask, request, jsonify
import os
from werkzeug.utils import secure_filename

app = Flask(__name__)

UPLOAD_FOLDER = 'uploads'
ALLOWED_EXTENSIONS = {'mp4', 'webm', 'mov', 'mkv'}
MAX_CONTENT_LENGTH = 1024 * 1024 * 1024  # 1 GB

app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
app.config['MAX_CONTENT_LENGTH'] = MAX_CONTENT_LENGTH

if not os.path.exists(UPLOAD_FOLDER):
    os.makedirs(UPLOAD_FOLDER)

def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

@app.route('/upload', methods=['POST'])
def upload_file():
    if 'file' not in request.files:
        return jsonify({'error': 'No file part'}), 400
    file = request.files['file']
    if file.filename == '':
        return jsonify({'error': 'No selected file'}), 400
    if file and allowed_file(file.filename):
        filename = secure_filename(file.filename)
        filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)
        file.save(filepath)
        return jsonify({'success': True, 'filename': filename}), 200
    else:
        return jsonify({'error': 'Invalid file type'}), 400

if __name__ == '__main__':
    app.run(debug=True, port=5000)
```

Okay. At first, this looks fine, but I can already point out an issue with the file uploading functionality: none of the functions, like ```upload_file```, have any type hints. This becomes a problem if you're working on code with other people, since the ```upload_file``` function returns a tuple without telling you. But I'll let GPT-5 off the hook here, since this is more of a code quality issue. 

A more glaring issue is that this code doesn't really implement GET request functionality, or a website. If I was a vibecoder, I'd want to access the app GPT-5 built for me on the browser -- I wouldn't know how to use CURL. 

Again, though, I can let GPT-5 off the hook for this, since my prompt may have been a little too basic. Let's ask it to make a proper web UI that can be accessed through the browser:

```python
HTML_FORM = """
<!doctype html>
<html>
  <head>
    <title>Video Upload</title>
  </head>
  <body>
    <h1>Upload a Video</h1>
    <form method="post" enctype="multipart/form-data">
      <input type="file" name="file" accept="video/*">
      <input type="submit" value="Upload">
    </form>
    {% if message %}
      <p>{{ message }}</p>
    {% endif %}
  </body>
</html>
"""

@app.route('/', methods=['GET', 'POST'])
def upload_file():
    message = None
    if request.method == 'POST':
        if 'file' not in request.files:
            message = 'No file part in request.'
        else:
            file = request.files['file']
            if file.filename == '':
                message = 'No file selected.'
            elif file and allowed_file(file.filename):
                filename = secure_filename(file.filename)
                filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)
                file.save(filepath)
                message = f'File uploaded successfully: {filename}'
            else:
                message = 'Invalid file type.'
    return render_template_string(HTML_FORM, message=message)

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000, debug=False)
```

GPT-5 is still allergic to type hints, but running this gives a nice web form to upload a video. Great! Not great when I consider that I'd have spent less time just coding it myself, but it's workable. Let's ask it for video streaming functionality now:

```python

VIDEO_PAGE = """
<!doctype html>
<html>
  <head>
    <title>Watching {{ filename }}</title>
  </head>
  <body>
    <h1>{{ filename }}</h1>
    <video width="640" height="360" controls>
      <source src="/videos/{{ filename }}" type="video/{{ ext }}">
      Your browser does not support the video tag.
    </video>
    <br><br>
    <a href="/">Back to upload page</a>
  </body>
</html>
"""

@app.route('/', methods=['GET', 'POST'])
def upload_file():
    message = None
    if request.method == 'POST':
        if 'file' not in request.files:
            message = 'No file part in request.'
        else:
            file = request.files['file']
            if file.filename == '':
                message = 'No file selected.'
            elif file and allowed_file(file.filename):
                filename = secure_filename(file.filename)
                filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)
                file.save(filepath)
                message = f'File uploaded successfully: {filename}'
            else:
                message = 'Invalid file type.'

    videos = os.listdir(UPLOAD_FOLDER)
    return render_template_string(HTML_TEMPLATE, message=message, videos=videos)

@app.route('/watch/<filename>')
def watch_video(filename):
    if not os.path.exists(os.path.join(UPLOAD_FOLDER, filename)):
        abort(404)
    ext = filename.rsplit('.', 1)[-1].lower()
    return render_template_string(VIDEO_PAGE, filename=filename, ext=ext)

@app.route('/videos/<filename>')
def serve_video(filename):
    if not os.path.exists(os.path.join(UPLOAD_FOLDER, filename)):
        abort(404)
    return send_from_directory(UPLOAD_FOLDER, filename)
```

Alright. To be honest, this is already a pain to read, and I really don't like its copious use of the ```os``` module here, but running it gives a working video streamer.

---
## Bookmarks and Cracks in the Manhattan Project

Right now, the Manhattan Project is relying on native video streaming as a crutch. Lets see what happens when I ask for custom functionality, like bookmarking a timestamp on a video:

```py

if os.path.exists(BOOKMARK_FILE):
    with open(BOOKMARK_FILE, 'r') as f:
        bookmarks = json.load(f)
else:
    bookmarks = {}

def save_bookmarks():
    with open(BOOKMARK_FILE, 'w') as f:
        json.dump(bookmarks, f, indent=2)

@app.route('/bookmark/<filename>', methods=['POST'])
def add_bookmark(filename):
    if not os.path.exists(os.path.join(UPLOAD_FOLDER, filename)):
        abort(404)
    ts = request.args.get('time', type=int)
    label = request.args.get('label', default=f"Bookmark at {ts}s")
    if ts is not None:
        bookmarks.setdefault(filename, []).append({"time": ts, "label": label})
        save_bookmarks()
    return '', 204
```

For starters, it added functionality to read bookmarks from a file, which I never asked for. GPT-5 has also used this check:

```py
    if not os.path.exists(os.path.join(UPLOAD_FOLDER, filename)):
        abort(404)
```

three times in the code now, without making it its own function. Annoying to read, but not critical.

Finally, I asked these bookmarks to be visible on the video stream itself. This is where GPT-5 started to falter: the bookmark's placements did not match up with the video's timeline.

![](/assets/img/gptwhy.png)

I decided to call it here, since the Manhattan Project started showing critical issues.

Unfortunately, I'm still not convinced vibe coding is the future. The code GPT-5 outputted was functional, but messy and poorly designed. Prompting it and influencing it to give me the correct code took significantly more time than if I was trying to code this myself. Sorry, LinkedIn, I think I'll keep my job for the foreseeable future.
